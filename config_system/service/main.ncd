include "http_server.ncdi"
include "job_queue.ncdi"
include "run_process_output.ncdi"
include "run_process_inout.ncdi"
include "temp_dir.ncdi"

process main {
    log_fr(@notice, {"Init"}, {"Exit"});
    
    # Read the configuration.
    getargs() args;
    value(args) args;
    args->get("0") config_path;
    file_read(config_path) config_contents;
    parse_value(config_contents) config;
    value(config) config;
    
    # Fetch stuff out of the configuration.
    config->get("http_server") http_server_config;
    config->get("max_concurrent_compiles") max_concurrent_compiles;
    config->get("aprinter_src_dir") aprinter_src_dir;
    config->get("temp_dir") temp_dir;
    config->get("mktemp") mktemp;
    config->get("rm") rm;
    config->get("python") python;
    config->get("nixbuild") nixbuild;
    config->get("tar") tar;
    config->get("mkdir") mkdir;
    
    # Change this to disable actual building, for testing.
    var(@false) test_without_building;
    
    # Init the queue.
    call(@job_queue, {max_concurrent_compiles}) queue;
    
    # Define the HTTP request handler.
    Block {
        alias(@_arg0) method;
        alias(@_arg1) path;
        alias(@_arg2) headers;
        alias(@_arg3) request_payload;
        objref_arg(_arg4) callbacks;
        objref_arg(_arg5) responses;
        
        # Buold the path to the io-helper.
        concat(aprinter_src_dir, "/config_system/service/io_helper.py") io_helper;
        
        # This block is used to reply to the compile request.
        Block {
            alias(@_arg0) reply_success;
            alias(@_arg1) reply_message;
            alias(@_arg2) reply_data_file;
            
            # Call the command for building the reply in JSON format.
            var({
                python, "-B", io_helper, "--build-reply", "--build-reply-success", reply_success,
                "--build-reply-message", reply_message, "--build-reply-data", reply_data_file,
                "--build-reply-dst", "-"
            }) build_reply_cmd;
            call(@run_process_output, {build_reply_cmd}) build_reply_exec;
            
            If (@not(build_reply_exec.succeeded)) {
                responses.internal_error->call();
            } Else {
                callbacks.set_content_type->call("application/json");
                callbacks.add_payload->call(build_reply_exec.output);
            };
        } reply_compile;
        
        Do {
            # Provide some warm and fuzzy text at /.
            If (@val_equal(path, "/")) {
                If (@not(@val_equal(method, "GET"))) {
                    responses.method_not_allowed->call();
                    _do->break();
                };
                
                value("") text;
                text->append("Hello curious user! You have reached the APrinter Compilation Service Backend.\n\n");
                text->append("Unfortunately there is nothing here to see.\n\n");
                text->append("Unless you are interested in hot new programming languages.\n");
                text->append("In that case you really should take a look at the source code of this software, ");
                text->append("which is written in the NCD Programming Language :)");
                
                callbacks.add_payload->call(text);
                _do->break();
            };
            
            # Unsupported request path?
            If (@not(@val_equal(path, "/compile"))) {
                responses.not_found->call();
                _do->break();
            };
            
            # Here we only support POST.
            If (@val_different(method, "POST")) {
                responses.method_not_allowed->call();
                _do->break();
            };
            
            callbacks.log->call(@notice, "compile request");
                
            # Wait in the queue until we're allowed to do the compilation.
            call(@job_queue_request, {^queue});
            
            callbacks.log->call(@notice, "compile started");
            
            # Create a temporary directory.
            call(@temp_dir, {^callbacks.log, temp_dir, mktemp, rm}) temp_dir;
            If (@not(temp_dir.succeeded)) {
                reply_compile->call(@false, "Could not make a temp dir.", "");
                _do->break();
            };
            
            # Create a subfolder which we will archive.
            concat(temp_dir.created_dir, "/aprinter-build") build_path;
            run({mkdir, build_path}, {});
            
            # Run the generate script.
            concat(aprinter_src_dir, "/config_system/generator/generate.py") generate_path;
            concat(aprinter_src_dir, "/nix") aprinter_nix_dir;
            var({python, "-B", generate_path, "--config", "-", "--output", "-", "--nix", "--nix-dir", aprinter_nix_dir}) generate_cmd;
            call(@run_process_inout, {generate_cmd, request_payload}) generate_exec;
            If (@not(generate_exec.succeeded)) {
                reply_compile->call(@false, "Generate script execution failed.", "");
                _do->break();
            };
            
            # Run nix-build, or simulate.
            concat(build_path, "/result") result_path;
            If (@not(test_without_building)) {
                var({nixbuild, "-", "-o", result_path}) nixbuild_cmd;
                call(@run_process_inout, {nixbuild_cmd, generate_exec.output}) nixbuild_exec;
                If (@not(nixbuild_exec.succeeded)) {
                    reply_compile->call(@false, "Could not perform the build via nix-build.", "");
                    _do->break();
                };
            } Else {
                call(@run_process_output, {{mkdir, result_path}}) mkdir_exec;
                If (@not(mkdir_exec.succeeded)) {
                    reply_compile->call(@false, "Could not mkdir for build simulation.", "");
                    _do->break();
                };
            };
            
            # Add the configuration to the build folder.
            concat(build_path, "/config.json") copy_config_path;
            var({python, "-B", io_helper, "--write-file", "--write-file-src", "-", "--write-file-dst", copy_config_path}) copy_config_cmd;
            call(@run_process_inout, {copy_config_cmd, request_payload}) copy_config_exec;
            If (@not(copy_config_exec.succeeded)) {
                reply_compile->call(@false, "Could not copy the build configuration.", "");
                _do->break();
            };
            
            # Produce the archive.
            concat(temp_dir.created_dir, "/aprinter-build.tar.bz2") archive_path;
            var({tar, "-cjf", archive_path, "-C", temp_dir.created_dir, "aprinter-build"}) archive_cmd;
            call(@run_process_output, {archive_cmd}) archive_exec;
            If (@not(archive_exec.succeeded)) {
                reply_compile->call(@false, "Could not archive the build results.", "");
                _do->break();
            };
            
            # Reply with success and the build archive.
            reply_compile->call(@true, "Compilation successful.", archive_path);
            
            callbacks.log->call(@notice, "compile finished");
        };
    } request_handler;
    
    # Start the HTTP server.
    call(@http_server, {http_server_config, ^request_handler});
}
