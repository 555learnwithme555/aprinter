commit 0fbbdf4ea1124df267ff430fed7b7b896057899e
Author: Ambroz Bizjak <ambrop7@gmail.com>
Date:   Thu Feb 4 00:09:35 2016 +0100

    emac: Remove the TX callbacks.
    
    This saves some memory.
    Also remove the unused old read/write functions.

diff --git a/sam/drivers/emac/emac.c b/sam/drivers/emac/emac.c
index ce53b19..8b5cf38 100644
--- a/sam/drivers/emac/emac.c
+++ b/sam/drivers/emac/emac.c
@@ -72,7 +72,6 @@ extern "C" {
 COMPILER_ALIGNED(8)
 static emac_tx_descriptor_t gs_tx_desc[EMAC_TX_BUFFERS];
 /** TX callback lists */
-static emac_dev_tx_cb_t gs_tx_callback[EMAC_TX_BUFFERS];
 /** RX descriptors lists */
 COMPILER_ALIGNED(8)
 static emac_rx_descriptor_t gs_rx_desc[EMAC_RX_BUFFERS];
@@ -230,15 +229,13 @@ static void emac_reset_rx_mem(emac_device_t* p_dev)
  * \param p_emac Pointer to EMAC instance. 
  * \param p_emac_dev Pointer to EMAC device instance.
  * \param p_dev_mm Pointer to the EMAC memory management control block.
- * \param p_tx_cb Pointer to allocated TX callback list.
  *
  * \return EMAC_OK or EMAC_PARAM.
  */
 static uint8_t emac_init_mem(Emac* p_emac, emac_device_t* p_emac_dev,
-		emac_dev_mem_t* p_dev_mm,
-		emac_dev_tx_cb_t* p_tx_cb)
+		emac_dev_mem_t* p_dev_mm)
 {
-	if (p_dev_mm->us_rx_size <= 1 || p_dev_mm->us_tx_size <= 1 || p_tx_cb == NULL) {
+	if (p_dev_mm->us_rx_size <= 1 || p_dev_mm->us_tx_size <= 1) {
 		return EMAC_PARAM;
 	}
 
@@ -265,7 +262,6 @@ static uint8_t emac_init_mem(Emac* p_emac, emac_device_t* p_emac_dev,
 			(emac_tx_descriptor_t *) ((uint32_t) p_dev_mm->p_tx_dscr 
 			& 0xFFFFFFF8);
 	p_emac_dev->us_tx_list_size = p_dev_mm->us_tx_size;
-	p_emac_dev->func_tx_cb_list = p_tx_cb;
 
 	/* Reset TX & RX */
 	emac_reset_rx_mem(p_emac_dev);
@@ -379,63 +375,12 @@ void emac_dev_init(Emac* p_emac, emac_device_t* p_emac_dev,
 	emac_dev_mm.p_tx_dscr = gs_tx_desc;
 	emac_dev_mm.us_tx_size = EMAC_TX_BUFFERS;
 
-	emac_init_mem(p_emac, p_emac_dev, &emac_dev_mm, gs_tx_callback);
+	emac_init_mem(p_emac, p_emac_dev, &emac_dev_mm);
 
 	emac_set_address(p_emac, 0, p_opt->uc_mac_addr);
 
 }
 
-/**
- * \brief Frames can be read from the EMAC in multiple sections.
- * Read ul_frame_size bytes from the EMAC receive buffers to pcTo.
- * p_rcv_size is the size of the entire frame.  Generally emac_read
- * will be repeatedly called until the sum of all the ul_frame_size equals
- * the value of p_rcv_size.
- *
- * \param p_emac_dev Pointer to the EMAC device instance. 
- * \param p_frame Address of the frame buffer.
- * \param ul_frame_size  Length of the frame.
- * \param p_rcv_size   Received frame size.
- *
- * \return EMAC_OK if receiving frame successfully, otherwise failed.
- */
-uint32_t emac_dev_read(emac_device_t* p_emac_dev, uint8_t* p_frame,
-		uint32_t ul_frame_size, uint32_t* p_rcv_size)
-{
-	uint8_t *data1;
-	uint8_t *data2;
-	uint32_t size1;
-	uint32_t size2;
-	emac_dev_read_state_t state;
-	uint32_t res;
-	
-	if (p_frame == NULL)
-		return EMAC_PARAM;
-
-	/* Set the default return value */
-	*p_rcv_size = 0;
-	
-	res = emac_dev_read_start(p_emac_dev, &state, &data1, &data2, &size1, &size2);
-	if (res != EMAC_OK) {
-		return res;
-	}
-	
-	*p_rcv_size = size1 + size2;
-	
-	if (*p_rcv_size > ul_frame_size) {
-		res = EMAC_SIZE_TOO_SMALL;
-	} else {
-		memcpy(p_frame, data1, size1);
-		if (size2 > 0) {
-			memcpy(p_frame + size1, data2, size2);
-		}
-	}
-	
-	emac_dev_read_end(p_emac_dev, &state);
-	
-	return res;
-}
-
 uint32_t emac_dev_read_start(emac_device_t* p_emac_dev, emac_dev_read_state_t *state,
 		uint8_t** p_data1, uint8_t** p_data2,
 		uint32_t* p_size1, uint32_t *p_size2)
@@ -525,35 +470,6 @@ void emac_dev_read_end(emac_device_t* p_emac_dev, emac_dev_read_state_t *state)
 	}
 }
 
-/**
- * \brief Send ulLength bytes from pcFrom. This copies the buffer to one of the
- * EMAC Tx buffers, and then indicates to the EMAC that the buffer is ready.
- * If lEndOfFrame is true then the data being copied is the end of the frame
- * and the frame can be transmitted.
- *
- * \param p_emac_dev Pointer to the EMAC device instance.
- * \param p_buffer       Pointer to the data buffer.
- * \param ul_size    Length of the frame.
- * \param func_tx_cb  Transmit callback function.
- *
- * \return Length sent.
- */
-uint32_t emac_dev_write(emac_device_t* p_emac_dev, void *p_buffer,
-		uint32_t ul_size, emac_dev_tx_cb_t func_tx_cb)
-{
-	void *dev_buffer;
-	uint32_t res = emac_dev_write_start(p_emac_dev, ul_size, &dev_buffer);
-	if (res != EMAC_OK) {
-		return res;
-	}
-	
-	if (p_buffer && ul_size) {
-		memcpy(dev_buffer, p_buffer, ul_size);
-	}
-	
-	return emac_dev_write_end(p_emac_dev, ul_size, func_tx_cb);
-}
-
 uint32_t emac_dev_write_start(emac_device_t* p_emac_dev, uint32_t ul_size, void **out_buffer)
 {
 	volatile emac_tx_descriptor_t *p_tx_td;
@@ -577,21 +493,14 @@ uint32_t emac_dev_write_start(emac_device_t* p_emac_dev, uint32_t ul_size, void
 	return EMAC_OK;
 }
 
-uint32_t emac_dev_write_end(emac_device_t* p_emac_dev, uint32_t ul_size, emac_dev_tx_cb_t func_tx_cb)
+uint32_t emac_dev_write_end(emac_device_t* p_emac_dev, uint32_t ul_size)
 {
 	volatile emac_tx_descriptor_t *p_tx_td;
-	volatile emac_dev_tx_cb_t *p_func_tx_cb;
 	Emac *p_hw = p_emac_dev->p_hw;
 	
 	/* Pointers to the current transmit descriptor */
 	p_tx_td = &p_emac_dev->p_tx_dscr[p_emac_dev->us_tx_head];
 
-	/* Pointers to the current Tx callback */
-	p_func_tx_cb = &p_emac_dev->func_tx_cb_list[p_emac_dev->us_tx_head];
-	
-	/* Tx callback */
-	*p_func_tx_cb = func_tx_cb;
-
 	/* Update transmit descriptor status */
 
 	/* The buffer size defined is the length of ethernet frame,
@@ -720,7 +629,6 @@ void emac_handler(emac_device_t* p_emac_dev)
 	Emac *p_hw = p_emac_dev->p_hw;
 
 	emac_tx_descriptor_t *p_tx_td;
-	emac_dev_tx_cb_t *p_tx_cb;
 	volatile uint32_t ul_isr;
 	volatile uint32_t ul_rsr;
 	volatile uint32_t ul_tsr;
@@ -766,7 +674,6 @@ void emac_handler(emac_device_t* p_emac_dev)
 			/* Status RLE & Number of discarded buffers */
 			ul_tx_status_flag = EMAC_TSR_RLES | CIRC_CNT(p_emac_dev->us_tx_head,
 					p_emac_dev->us_tx_tail, p_emac_dev->us_tx_list_size);
-			p_tx_cb = &p_emac_dev->func_tx_cb_list[p_emac_dev->us_tx_tail];
 			emac_reset_tx_mem(p_emac_dev);
 			emac_enable_transmit(p_hw, 1);
 		}
@@ -789,29 +696,16 @@ void emac_handler(emac_device_t* p_emac_dev)
 			/* Check the buffers */
 			do {
 				p_tx_td = &p_emac_dev->p_tx_dscr[p_emac_dev->us_tx_tail];
-				p_tx_cb = &p_emac_dev->func_tx_cb_list[p_emac_dev->us_tx_tail];
 				/* Any error? Exit if buffer has not been sent yet */
 				if ((p_tx_td->status.val & EMAC_TXD_USED) == 0) {
 					break;
 				}
 
-				/* Notify upper layer that a packet has been sent */
-				if (*p_tx_cb) {
-					(*p_tx_cb) (ul_tx_status_flag);
-				}
-
 				circ_inc(&p_emac_dev->us_tx_tail, p_emac_dev->us_tx_list_size);
 			} while (CIRC_CNT(p_emac_dev->us_tx_head, p_emac_dev->us_tx_tail,
 							p_emac_dev->us_tx_list_size));
 		}
 
-		if (ul_tsr & EMAC_TSR_RLES) {
-			/* Notify upper layer RLE */
-			if (*p_tx_cb) {
-				(*p_tx_cb) (ul_tx_status_flag);
-			}
-		}
-
 		/* If a wakeup has been scheduled, notify upper layer that it can
 		   send other packets, and the sending will be successful. */
 		if ((CIRC_SPACE(p_emac_dev->us_tx_head, p_emac_dev->us_tx_tail,
diff --git a/sam/drivers/emac/emac.h b/sam/drivers/emac/emac.h
index 095868f..34036c3 100644
--- a/sam/drivers/emac/emac.h
+++ b/sam/drivers/emac/emac.h
@@ -231,8 +231,6 @@ typedef struct emac_device {
 	emac_dev_tx_cb_t func_rx_cb;
 	/** Optional callback to be invoked once several TDs have been released */
 	emac_dev_wakeup_cb_t func_wakeup_cb;
-	/** Optional callback list to be invoked once TD has been processed */
-	emac_dev_tx_cb_t *func_tx_cb_list;
 	/** RX TD list size */
 	uint16_t us_rx_list_size;
 	/** RX index for current processing TD */
@@ -1007,16 +1005,12 @@ uint8_t emac_phy_write(Emac* p_emac, uint8_t uc_phy_address,
 		uint8_t uc_address, uint32_t ul_value);
 void emac_dev_init(Emac* p_emac, emac_device_t* p_emac_dev,
 		emac_options_t* p_opt);
-uint32_t emac_dev_read(emac_device_t* p_emac_dev, uint8_t* p_frame,
-		uint32_t ul_frame_size, uint32_t* p_rcv_size);
 uint32_t emac_dev_read_start(emac_device_t* p_emac_dev, emac_dev_read_state_t *state,
 		uint8_t** p_data1, uint8_t** p_data2,
 		uint32_t* p_size1, uint32_t *p_size2);
 void emac_dev_read_end(emac_device_t* p_emac_dev, emac_dev_read_state_t *state);
-uint32_t emac_dev_write(emac_device_t* p_emac_dev, void *p_buffer,
-		uint32_t ul_size, emac_dev_tx_cb_t func_tx_cb);
 uint32_t emac_dev_write_start(emac_device_t* p_emac_dev, uint32_t ul_size, void **out_buffer);
-uint32_t emac_dev_write_end(emac_device_t* p_emac_dev, uint32_t ul_size, emac_dev_tx_cb_t func_tx_cb);
+uint32_t emac_dev_write_end(emac_device_t* p_emac_dev, uint32_t ul_size);
 uint32_t emac_dev_get_tx_load(emac_device_t* p_emac_dev);
 void emac_dev_set_rx_callback(emac_device_t* p_emac_dev,
 		emac_dev_tx_cb_t func_rx_cb);
